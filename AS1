#define _POSIX_C_SOURCE 200809L 
#include <stdio.h> 
#include <unistd.h> 
#include <string.h> 
#include <stddef.h> 
#include <stdlib.h> 
#include <sys/wait.h>

#define MAX_LINE 80 
#define NOT_ID 0 
#define MIN_ID 1 
#define MAX_ID 10 

typedef struct
{
    pid_t pid; 
    char command[MAX_LINE + 1]; 
} record;

void free_args(char **args, unsigned nargs)
{
    unsigned i;
    for (i = 0; i < nargs; i++)
        free(args[i]);
}

int parse_command(char *command, char *buf, char **args, unsigned nargs,
    unsigned max_nargs)
{
    char *token; 
    unsigned len; 
    unsigned i; 

    free_args(args, nargs);
    nargs = 0;
    for (i = 0; i < max_nargs; i++)
        args[i] = NULL;

    len = strlen(command);
    if (len > 0 && command[len - 1] == '\n')
        command[--len] = '\0';

    strcpy(buf, command);
    token = strtok(buf, " ");

    if (!token) {
        args[nargs] = strdup(buf);
        return ++nargs;
    }

    while (token && nargs + 1 < max_nargs) {
        args[nargs] = strdup(token);
        nargs++;
        token = strtok(NULL, " ");
    }
    if (token) {
        free_args(args, nargs);
        return 0;
    }
    return nargs;
}

int parse_number(const char *str, char *buf, int *num)
{
    if (sscanf(str, "%d", num) != 1)
        return 0;
    sprintf(buf, "%d", *num);
    if (0 != strcmp(buf, str))
        return 0;
    return 1;
}

int my_exit(int status, char **args, int nargs)
{
    free_args(args, nargs);
    exit(status);
}

int main(void)
{
    char *args[MAX_LINE/2 + 1]; 
    int should_run = 1; 
    char command[MAX_LINE + 2]; 
    char buf[MAX_LINE + 2]; 
    int nargs = 0; 
    const int max_nargs = MAX_LINE/2 + 1; 
    pid_t pid; 
    record history[MAX_ID]; 
    int last_id = NOT_ID; 
    int i; 
    int num;

    while (should_run) {
        printf("CSCI3120>");
        fflush(stdout);

        if (!fgets(command, sizeof(command), stdin))
            my_exit(EXIT_FAILURE, args, nargs);

        if (!(nargs = parse_command(command, buf, args, nargs, max_nargs)))
            my_exit(EXIT_FAILURE, args, nargs);

        if (!strcspn(args[0], " ")) {
            continue;
        }

        if (0 == strcmp(args[0], "exit")) {
            if (nargs != 1) {
                printf("Invalid syntax of the command\n");
            } else {
                should_run = 0;
            }
            continue;
        }

        if (0 == strcmp(args[0], "history")) {
            if (nargs != 1) {
                printf("Invalid syntax of the command\n");
            } else if (last_id == NOT_ID) {
                printf("No commands in history\n");
            } else {
                printf("%-5s%-9s%s\n", "ID", "PID", "Command");
                for (i = 0; i < last_id; i++) {
                    printf("%-5d%-9d%s\n", i + 1, history[i].pid,
                        history[i].command);
                }
            }
            continue;
        }

        if (0 == strcmp(args[0], "!!")) {
            if (nargs != 1) {
                printf("Invalid syntax of the command\n");
                continue;
            } else if (last_id == NOT_ID) {
                printf("No commands in history\n");
                continue;
            } else {
                strcpy(command, history[last_id - 1].command);
                nargs = parse_command(command, buf, args, nargs, max_nargs);
            }
        }

        if (args[0][0] == '!') {
            if (nargs != 1 || !parse_number(args[0] + 1, buf, &num)) {
                printf("Invalid syntax of the command\n");
                continue;
            } else if (num < MIN_ID || num > last_id) {
                printf("No such command in history\n");
                continue;
            } else {
                strcpy(command, history[num - 1].command);
                nargs = parse_command(command, buf, args, nargs, max_nargs);
            }
        }

        /**
         * After reading user input, the steps are:
         * (1) fork a child process using fork()
         * (2) the child process will invoke execvp()
         * (3) parent will invoke wait()
         */
        pid = fork();
        if (pid < 0)
            my_exit(EXIT_FAILURE, args, nargs);
        if (pid == 0) {
            if (-1 == execvp(args[0], args)) {
                printf("Invalid command\n");
                my_exit(EXIT_FAILURE, args, nargs);
            }
        }
        if (pid > 0) {
            if (last_id >= MAX_ID) {
                for (i = MIN_ID; i < MAX_ID; i++)
                    history[i - 1] = history[i];
                last_id = MAX_ID - 1;
            }
            history[last_id].pid = pid;
            strcpy(history[last_id].command, command);
            last_id++;

            wait(NULL);
        }
    }

    my_exit(EXIT_SUCCESS, args, nargs);
    return 0; 
}
