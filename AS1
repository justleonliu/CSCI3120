#define _POSIX_C_SOURCE 200809L /* to support strdup() */
#include <stdio.h> /* printf(), sscanf(), sprintf(), fflush(), stdout, fgets(),
    stdin */
#include <unistd.h> /* fork(), execvp() */
#include <string.h> /* strlen(), strcpy(), strtok(), strcspn() */
#include <stddef.h> /* NULL */
#include <stdlib.h> /* exit(), EXIT_FAILURE, free() (bcs dup()), EXIT_SUCCESS */
#include <sys/wait.h> /* wait() */

#define MAX_LINE 80 /* The maximum length of a command */
#define NOT_ID 0 /* The default ID if the history is empty */
#define MIN_ID 1 /* The initial ID of a record in the history */
#define MAX_ID 10 /* The maximum size of the history */

typedef struct
{
    pid_t pid; /* process identifier of the process that executed the command */
    char command[MAX_LINE + 1]; /* command executed by the user */
} record;

void free_args(char **args, unsigned nargs)
{
    unsigned i; /* loop variable */
    for (i = 0; i < nargs; i++)
        free(args[i]);
}

int parse_command(char *command, char *buf, char **args, unsigned nargs,
    unsigned max_nargs)
{
    char *token; /* pointer to the found token */
    unsigned len; /* the length of the command */
    unsigned i; /* loop variable */

    free_args(args, nargs);
    nargs = 0;
    for (i = 0; i < max_nargs; i++)
        args[i] = NULL;

    len = strlen(command);
    if (len > 0 && command[len - 1] == '\n')
        command[--len] = '\0';

    strcpy(buf, command);
    token = strtok(buf, " ");

    if (!token) {
        args[nargs] = strdup(buf);
        return ++nargs;
    }

    while (token && nargs + 1 < max_nargs) {
        args[nargs] = strdup(token);
        nargs++;
        token = strtok(NULL, " ");
    }
    if (token) {
        free_args(args, nargs);
        return 0;
    }
    return nargs;
}

int parse_number(const char *str, char *buf, int *num)
{
    if (sscanf(str, "%d", num) != 1)
        return 0;
    sprintf(buf, "%d", *num);
    if (0 != strcmp(buf, str))
        return 0;
    return 1;
}

int my_exit(int status, char **args, int nargs)
{
    free_args(args, nargs);
    exit(status);
}

int main(void)
{
    char *args[MAX_LINE/2 + 1]; /* command line arguments */
    int should_run = 1; /* flag to determine when to exit program */
    char command[MAX_LINE + 2]; /* one for \0, another for \n */
    char buf[MAX_LINE + 2]; /* to tokenize the command */
    int nargs = 0; /* number of valid elements in args */
    const int max_nargs = MAX_LINE/2 + 1; /* number of elements in args */
    pid_t pid; /* pid of the child */
    record history[MAX_ID]; /* history of the recently-entered commands */
    int last_id = NOT_ID; /* the last used ID */
    int i; /* loop variable */
    int num; /* for the !N command */

    while (should_run) {
        printf("CSCI3120>");
        fflush(stdout);

        if (!fgets(command, sizeof(command), stdin))
            my_exit(EXIT_FAILURE, args, nargs);

        if (!(nargs = parse_command(command, buf, args, nargs, max_nargs)))
            my_exit(EXIT_FAILURE, args, nargs);

        if (!strcspn(args[0], " ")) {
            continue;
        }

        if (0 == strcmp(args[0], "exit")) {
            if (nargs != 1) {
                printf("Invalid syntax of the command\n");
            } else {
                should_run = 0;
            }
            continue;
        }

        if (0 == strcmp(args[0], "history")) {
            if (nargs != 1) {
                printf("Invalid syntax of the command\n");
            } else if (last_id == NOT_ID) {
                printf("No commands in history\n");
            } else {
                printf("%-5s%-9s%s\n", "ID", "PID", "Command");
                for (i = 0; i < last_id; i++) {
                    printf("%-5d%-9d%s\n", i + 1, history[i].pid,
                        history[i].command);
                }
            }
            continue;
        }

        if (0 == strcmp(args[0], "!!")) {
            if (nargs != 1) {
                printf("Invalid syntax of the command\n");
                continue;
            } else if (last_id == NOT_ID) {
                printf("No commands in history\n");
                continue;
            } else {
                strcpy(command, history[last_id - 1].command);
                nargs = parse_command(command, buf, args, nargs, max_nargs);
            }
        }

        if (args[0][0] == '!') {
            if (nargs != 1 || !parse_number(args[0] + 1, buf, &num)) {
                printf("Invalid syntax of the command\n");
                continue;
            } else if (num < MIN_ID || num > last_id) {
                printf("No such command in history\n");
                continue;
            } else {
                strcpy(command, history[num - 1].command);
                nargs = parse_command(command, buf, args, nargs, max_nargs);
            }
        }

        /**
         * After reading user input, the steps are:
         * (1) fork a child process using fork()
         * (2) the child process will invoke execvp()
         * (3) parent will invoke wait()
         */
        pid = fork();
        if (pid < 0)
            my_exit(EXIT_FAILURE, args, nargs);
        if (pid == 0) {
            if (-1 == execvp(args[0], args)) {
                printf("Invalid command\n");
                my_exit(EXIT_FAILURE, args, nargs);
            }
        }
        if (pid > 0) {
            if (last_id >= MAX_ID) {
                for (i = MIN_ID; i < MAX_ID; i++)
                    history[i - 1] = history[i];
                last_id = MAX_ID - 1;
            }
            history[last_id].pid = pid;
            strcpy(history[last_id].command, command);
            last_id++;

            wait(NULL);
        }
    }

    my_exit(EXIT_SUCCESS, args, nargs);
    return 0; /* has the same effect as exit(0) or exit(EXIT_SUCCESS); this
        line should prevent some compiler warnings */
}
